\documentclass{beamer}

\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{hyperref}

\usepackage{fancyvrb}

\title{Introduzione a \texttt{git}}
\author{Luca Tagliavini, Stefano Volpe}
\institute{Università di Bologna, corso di Laurea in Informatica}
\date{8 novembre 2022}
\logo{\includegraphics[width=0.05\textwidth]{assets/by-nc-sa-4-0.png}}

\AtBeginSection[]{
  \begin{frame}
    \frametitle{In questa sezione}
    \setcounter{tocdepth}{2}
    \tableofcontents[currentsection]
  \end{frame}
}

\begin{document}

\begin{frame} 
  \titlepage
\end{frame}

\section{Controllo di versione}

\subsection{Problemi}
\begin{frame}{Problemi}
  Quando lavoriamo con molti \emph{file} (redigiamo documenti, creiamo arte
  digitale, scriviamo codice...), ricorrono alcuni \textbf{problemi}:\pause
  \begin{itemize}
    \item<1-> mantenere una \textbf{cronologia} delle modifiche;\pause
    \item<2-> \textbf{ripristinare} subito un qualsiasi stato precedente;\pause
    \item<3-> collaborare a \textbf{copie diverse} dello stesso progetto.\pause
  \end{itemize}
  Copie di cartelle e blocchi note condivisi in rete non bastano più!
\end{frame}

\subsection{Rimedi}
\begin{frame}{Rimedi}
  \begin{definition}
    Un \textbf{sistema per il controllo di versione} (o VCS, \emph{version control
    system}) è un applicativo che gestisce modifiche a grandi insiemi di
    informazioni.
  \end{definition}\pause
  \begin{figure}
    \includegraphics[width=\textwidth]{assets/vcs-popularity.png}
    \caption{popolarità su Google dei cinque principali VCS
    (\textcolor{cyan}{\texttt{git}}, \textcolor{red}{SVN},
    \textcolor{orange}{Mercurial}, \textcolor{green}{Perforce},
    \textcolor{violet}{CVS}) negli ultimi cinque anni. In ordinata, 100 indica il
    massimo storico del più popolare di questi in tale lasso di tempo.}
  \end{figure}
\end{frame}

\subsection{Ambiente di lavoro}
\begin{frame}{Ambiente di lavoro | Scopo}
  Nei prossimi lucidi, collegandoci alle macchine di laboratorio con i nostri
  utenti, useremo \texttt{git} da linea di comando.\pause
  \begin{block}{Consiglio}
    Tenete aperta questa presentazione anche sulla vostra macchina durante il
    laboratorio: potete trovarla su
    \href{https://csunibo.github.io/lab}{\beamergotobutton{csunibo.github.io/lab}}.
  \end{block}
\end{frame}

\begin{frame}{Ambiente di lavoro | Materiali}
  Materiali:
  \begin{enumerate}
    \item<1->un utente nella rete dipartimentale (es. \texttt{stefano.volpe2});
      \begin{alertblock}{Se siete senza utente...}
        ... (e non avete \texttt{git} neanche sulla vostra macchina), seguite con
        chi siede al vostro fianco.
      \end{alertblock}\pause
    \item<2->un client \texttt{ssh}. Su Linux e macOS è già installato; su
      Windows, se vi manca, c'è
      \href{https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html}{\beamergotobutton{PuTTY}}.
  \end{enumerate}
\end{frame}

\begin{frame}{Ambiente di lavoro | Preparazione}
  Preparazione:
  \begin{enumerate}
    \item<1->scegliere una delle \href{https://disi.unibo.it/it/dipartimento/servizi-tecnici-e-amministrativi/servizi-informatici/accesso-remoto}{\beamergotobutton{macchine
      di laboratorio}} (es. \texttt{XXX.cs.unibo.it}, dove \texttt{XXX} è il
      nome della macchina scelta)
    \item<2-> collegarsi:
      \begin{semiverbatim}
        \$ ssh stefano.volpe2@XXX.cs.unibo.it
      \end{semiverbatim}
  \end{enumerate}
\end{frame}

\begin{frame}{Ambiente di lavoro | Preparazione (2)}
  \begin{semiverbatim}
  \lbrack ...\rbrack \newline
  Are you sure you want to continue connecting \newline (yes/no/\lbrack
  fingerprint\rbrack)? yes \newline
  \lbrack ...\rbrack \newline
  stefano.volpe2@XXX.cs.unibo.it's password:
  \end{semiverbatim}
\end{frame}

\begin{frame}{Ambiente di lavoro | Preparazione (3)}
  \begin{enumerate}
    \setcounter{enumi}{2}
    \item configurare \texttt{git} con i vostri dati:
    \begin{semiverbatim}
    \$ git config --global user.name "Luca Tagliavini"
    \end{semiverbatim}
    \begin{semiverbatim}
    \$ git config --global user.email \\
    \end{semiverbatim}
    \begin{semiverbatim}
        \qquad"luca.tagliavini5@studio.unibo.it"
    \end{semiverbatim}
  \end{enumerate}
\end{frame}

\section{Basi di \texttt{git}}

\subsection{\texttt{git init}}
\begin{frame}
  \frametitle{\texttt{git init}}
\end{frame}

\subsection{\texttt{git add}}
\begin{frame}
  \frametitle{\texttt{git add}}
\end{frame}

\subsection{\texttt{git status, commit}}
\begin{frame}
  \frametitle{\texttt{git status, commit}}
\end{frame}

\subsection{\texttt{git log, show}}
\begin{frame}
  \frametitle{\texttt{git log}}
\end{frame}

\begin{frame}
  \frametitle{\texttt{git show}}
\end{frame}

\subsection{\texttt{git branch, checkout, switch}}
\begin{frame}
  \frametitle{\texttt{git branch, checkout, switch}}
\end{frame}

\begin{frame}[c]
  \centering
  Pausa
\end{frame}

\subsection{\texttt{git merge, rebase}}
\begin{frame}
  \frametitle{\texttt{git merge, rebase}}
  Per unire il lavoro svolto su branch separate si hanno due opzioni che operano
  in modo diverso ed hanno casi d'uso separati:
  \begin{enumerate}
    \item<1-> \texttt{git merge <name>}: applica tutti i \emph{nuovi commit}\footnotemark{}
      presenti sulla branch \texttt{<name>} nella branch in cui ci troviamo;
    \item<2-> \texttt{git rebase <name>}: mette da parte i
      \emph{nuovi commit}\footnotemark[\value{footnote}], avanza la branch
      all'ultimo commit su \texttt{<name>} e riapplica i commit "messi da parte".
  \end{enumerate}
      \footnotetext{Tutti quelli a partire dal \emph{fork-point}}
\end{frame}

\begin{frame}
  \frametitle{\texttt{git merge} | Pregi e difetti}
  \begin{itemize}
    \item Pregi: \begin{itemize}
      \item Preserva \emph{chiaramente} la storia dei commit;
      \item Pu\`o essere usato su branch pubbliche.
    \end{itemize}
    \item Difetti: \begin{itemize}
      \item Aggiunge un nuovo commit alla storia;
      \item Tutti i commit della branch vengono condensati in uno\footnote{
          Sar\`a comunque possibile visionare tutti i commit della branch unita,
          anche dopo la sua rimozione.
        }.
    \end{itemize}
  \end{itemize}

  Da usare quando si collabora con altre persone e si vuole rendere la storia
  dei cambiamenti facilmente comprensibile.
\end{frame}

\begin{frame}
  \frametitle{\texttt{git rebase} | Pregi e difetti}
  \begin{itemize}
    \item Pregi: \begin{itemize}
      \item Non crea commit aggiuntivi, rende la storia lineare;
      \item Si possono compiere modifiche ai commit precedenti durante l'unione
        delle due branch.
    \end{itemize}
    \item Difetti: \begin{itemize}
      \item Non \`e possibile collegare i commit riapplicati a quelli originali;
      \item \textbf{Non} pu\`o essere usato su branch pubbliche;
      \item Pu\`o sovrascrivere la storia e di conseguenza potrebbe
        richiedere un \texttt{push} forzato.
    \end{itemize}
  \end{itemize}

  Torna utile quando si lavora in locale o su branch private, per coprire i
  propri sbagli o ripulire una storia dei commit poco ordinata.
\end{frame}

\begin{frame}
  \frametitle{\texttt{git merge}}
  Il caso d'uso tipico per il comando \texttt{merge} \`e l'unione di una branch
  secondaria con quella principale. Il comando ha la seguente sintassi:
  \begin{semiverbatim}
  \$ git merge <branch>
  \end{semiverbatim}

  \begin{figure}
  \only<1>{
    \includegraphics[width=5cm]{assets/pre-merge.png}
    \caption{Log dei commit prima di un merge}
  }
  \only<2>{
    \includegraphics[width=5cm]{assets/post-merge.png}
    \caption{Log dei commit dopo $git merge feat$}
  }
  \end{figure}

  \pause
  \begin{block}{Nota}
    \`E sconsigliato usare \texttt{merge} con un spazio di lavoro sporco
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{\texttt{git rebase}}
  Il comando \texttt{rebase} si usa quando si vuole cambiare il ramo su cui si
  basa la branch attuale. Tipicamente questo si rende necessario perch\`e il
  ramo su cui ci si basa \`e stato unito con la branch di sviluppo principale.
  La sintassi \`e la seguente:
  \begin{semiverbatim}
  \$ git rebase <branch>
  \end{semiverbatim}
  Di seguito \`e raffigurata una casistica d'esempio.

  \begin{figure}
  \only<1>{
    \includegraphics[width=5cm]{assets/pre-rebase.png}
    \caption{Log dei commit prima di un rebase}
  }
  \only<2>{
    \includegraphics[width=7cm]{assets/post-rebase.png}
    \caption{Log dei commit dopo \texttt{git rebase main}}
  }
  \end{figure}
\end{frame}

\begin{frame}
  \label{trivial}
  \frametitle{\texttt{git merge, rebase} | Caso triviale}
  In un caso triviale, ovvero quando tra le branch da unificare solo una contiene
  cambiamenti dopo il \emph{fork-point}, i comandi \texttt{merge} e \texttt{rebase}
  hanno lo stesso effetto\footnote{Nel caso del \texttt{merge} non viene
  aggiunto nessun commit, si dice che viene fatto un \emph{fast forward}}:
  \begin{figure}
    \centering
    \subfloat{\includegraphics[width=5cm]{assets/pre-trivial.png}}
    \quad
    \subfloat{\includegraphics[width=5cm]{assets/post-trivial.png}}
    \caption{Prima e dopo un \texttt{git merge feat} o \texttt{git rebase feat}}
  \end{figure}
\end{frame}

\begin{frame}
  \label{conflict}
  \frametitle{\texttt{git merge, rebase} | Conflitti}
  Quando si vanno a unire due branch \`e possibile che si trovino conflitti tra
  i vari commit che si stanno provando ad unire. \texttt{git} si comporta in modo diverso
  in base al tipo di unione che si sta svolgendo.
  \begin{itemize}
    \item<1-> Nel caso di un \texttt{merge} tutti i commit vengono applicati e 
      i file contenenti conflitti vengono segnalati all'utente. Sar\`a suo
      compito correggerli e creare il merge commit;
    \item<2-> Nel caso di un \texttt{rebase} i commit vengono applicati uno ad
      uno, fermandosi quando si trovano conflitti. L'utente ha il compito di
      correggerli e far ripartire la procedura di \texttt{rebase}, iterando
      in questo modo fino al completamento.
  \end{itemize}
  In entrambi i casi il comando \texttt{git status} mostra informazioni utili
  sullo stato della procedura di unione.
\end{frame}

\begin{frame}
  \label{conflict-end}
  \frametitle{\texttt{git rebase} | Conflitti}
  Quando si incontrano conflitti durante un \texttt{rebase} si hanno in
  realt\`a tre scelte:
  \begin{itemize}
    \item<1-> Correggere i conflitti e lanciare \texttt{git rebase --continue}: questo
      modificher\`a il diff del commit originale e consentir\`a di produrre un
      commit che non provoca errori con l'attuale albero di lavoro;
    \item<2-> Ignorare i cambiamenti apportati da questo particolare commit (che
      sta causando i conflitti) con \texttt{git rebase --skip};
    \item<3-> Annullare l'intera operazione con \texttt{git rebase --abort}
  \end{itemize}
\end{frame}

\section{Collaborazione remota}
\begin{frame}{Perch\`e?}
  Una repository locale pu\`o essere collegata ad una \textbf{remota} per
  semplificare una serie di operazioni comuni e desiderabili:
  \begin{itemize}
    \item<1-> collaborazione tra sviluppatori, interni o esterni al proprio gruppo di lavoro;
    \item<2-> distribuzione del codice (versionamento e rilascio);
    \item<3-> backup del codice.
  \end{itemize}
\end{frame}

\subsection{\texttt{git remote}}
\begin{frame}
  \frametitle{\texttt{git remote [show]}}
  La gestione degli \emph{endpoint} remoti a cui si vuole collegare la propria
  repository avviene tramite la famiglia di comandi \texttt{git remote}.
  Per ottenere la lista dei remoti collegati ad un albero di git si pu\`o usare:
  \begin{semiverbatim}
  \$ git remote [-v]
  \end{semiverbatim}
  Applicando la flag \texttt{-v} si rende la risposta verbosa e si ottengono
  ancora pi\`u dettagli, ad esempio gli \texttt{URI} degli endpoint\footnote{
    Per ottenere ancora pi\`u informazioni si pu\`o usare il comando \texttt{git remote show <name>}
  }.
\end{frame}

\begin{frame}
  \frametitle{\texttt{git remote add, remove}}
  Per aggiungere un nuovo remoto alla repository possiamo usare il comando:
  \begin{semiverbatim}
  \$ git remote add <name> <uri>
  \end{semiverbatim}
  Il nome standard per il remoto principale \`e \emph{origin}. L'\texttt{URI}
  deve usare uno dei protoccoli accettati\footnote{Vedi:
    \href{https://stackoverflow.com/a/51112344}{\beamergotobutton{stackoverflow.com/a/51112344}}}.

    \pause
  \texttt{remove} \`e il sottocomando speculare ad \texttt{add} che consente di
  rimuovere un remoto dato il nome:
  \begin{semiverbatim}
  \$ git remote remove <name>
  \end{semiverbatim}
\end{frame}

\begin{frame}
  \frametitle{\texttt{git remote add, remove} | Nota sugli URI}
  Nella maggior parte dei servizi moderni che ospitano repository di \texttt{git}
  l'utilizzo di \texttt{HTTP(S)} come protocollo per il collegamento remoto \`e
  stato deprecato per ragioni di sicurezza. In questa guida useremo sempre
  remoti con protocollo \texttt{SSH} e voi dovreste fare altrettanto.
\end{frame}

\subsection{\texttt{git push}}
\begin{frame}
  \frametitle{\texttt{git push}}
  Una volta aggiunto un endpoint \`e possibile caricare i propri commit alla
  repository remota:
  \begin{semiverbatim}
  \$ git push [-u] [<name>]
  \end{semiverbatim} \pause
  \begin{block}{Nota}
    Dover specificare il nome del remoto ogni volta pu\`o diventare tedioso, di
    conseguenza \`e tipico identificare un remoto "di default"\footnote{Denominato \emph{upstream}}
    \emph{per ogni branch}. Questo sar\`a il remoto a cui inviare i cambiamenti
    quando \texttt{<name>} \`e omesso. La flag \texttt{-u} del comando \texttt{push}
    imposta un remoto come \texttt{upstream}.
  \end{block}
\end{frame}

\subsection{\texttt{git fetch, pull}}
\begin{frame}
  \frametitle{\texttt{git fetch}}
  Per ricevere i cambiamenti caricati ad un remoto si pu\`o usare il comando:
  \begin{semiverbatim}
  \$ git fetch [<remote>]
  \end{semiverbatim} \pause
  Quando viene omesso \texttt{<remote>} il comando scarica aggiornamenti dal
  remoto \emph{origin} o dal remoto configurato come \emph{upstream} per la
  branch attuale.
\end{frame}

\begin{frame}
  \frametitle{\texttt{git pull}}
  Quasi sempre si deisdera anche unire la branch attuale con quella remota.
  Il comando \texttt{git pull} esegue \texttt{fetch} e in seguito \texttt{merge}
  o \texttt{rebase} in base alla configurazione di \texttt{git} per riconciliare l'albero
  locale con quello remoto. \\ \pause
  \begin{itemize}
    \item Nel caso non ci siano cambiamenti locali non caricati viene eseguito
      un \emph{fast-forward}\footnote{Vedi Lucido \ref{trivial}}.
    \item Se ci sono cambiamenti non presenti in alcun commit che causerebbero
      conflitti il \texttt{pull} viene interrotto in attesa che essi vengano
      inseriti in un commit o rimossi.
    \item Altrimenti \texttt{git} esegue \texttt{merge} o \texttt{rebase} e lascia il
      controllo all'utente in caso di conflitti come descritto nei
      Lucidi \ref{conflict}-\ref{conflict-end}.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{\texttt{git pull} | Nota}
  La prima volta che si esegue un pull che incontrer\`a conflitti verr\`a
  mostrato un messaggio chiedendovi di configurare il metodo di riconciliazione.
  La \emph{best practice} in questo caso \`e usare la tecnica di rebase, in
  quanto i cambiamenti in locale che hanno portato ai conflitti sono per
  definizione \emph{privati} ed \`e preferibile mantenere la storia dei commit
  lineare. Si pu\`o impostare questa come default tramite:
  \begin{semiverbatim}
  \$ git config --global pull.rebase true
  \end{semiverbatim}
  \pause
  Se, dopo aver impostato la propria preferenza, si desidera eseguire un
  \texttt{pull} con un altro metodo di riconciliazione, si pu\`o specificare tramite:
  \begin{semiverbatim}
  \$ git pull [--rebase] [--merge]
  \end{semiverbatim}
\end{frame}

\subsection{\texttt{git clone}}
\begin{frame}
  \frametitle{\texttt{git clone}}
  Per duplicare una repository remota sul proprio sistema si ha a disposizione
  il comando:
  \begin{semiverbatim}
  \$ git clone [-b <branch>] <uri>
  \end{semiverbatim}
  Dove l'\texttt{URI} \`e l'indirizzo dove \`e salvato il vostro codice.
  \pause
  \begin{block}{Consiglio}
    Per clonare una specifica branch si pu\`o usare la flag \texttt{-b}
    specificando subito dopo il nome della branch remota desiderata.
  \end{block}
\end{frame}

\end{document}
